# Plagiarism Detection Explained

Due to the complex nature of source code plagiarism detection problem, many of the algorithms attempting to address it tend to focus on a specific set of aspects as the evidence for categorization. Thus, it is challenging to fully cover all cases of plagiarism using one single ominous algorithm. To provide as much trustability and insight into the plagiarism detection problem as possible, the Autograder uses a fleet of different approaches and present the result as a summarization of the output of each individual approach. This how-to article aims to 1) explain how each algorithm works behind the scene 2) show the strength and weakness of the algorithms using some attack case experiments.

## Algorithms Used
The Autograder's plagiarism detection module consists of six different algorithms:
* Exact Match
* Unifying AST Match
* Unifying AST Match (ignore variable names)
* Tree Edit Distance (RTED)
* Winnowing
* Comment Edit Distance (Levenshtein)

Most of the algorithms mentioned above took use of the Abstract Syntax Tree (AST), which refers to the tree representation for the abstract syntactic structure of source code. It is worth noticing that AST only covers the structural and content-wise detail of the code and ignores aspects that are irrelevant to the execution outcome of it (e.g. comments and grouping parentheses), which is beneficial for source code plagiarism detection.

### Exact Match
As its name suggests, the exact match algorithm compares each node within an AST and only returns true if the relationship between all the nodes and their contents are identical. A positive output of the exact match algorithm strongly suggests that the two pieces code are almost exactly the same despite the possibility of small changes (e.g. comments / whitespaces).

### Unifying AST Match
The unifying AST match is a match between the abstract syntax trees of two programs that finds a one-to-one mapping between the variable names of the two programs. This category can then allow programs in which all variables have been renamed in a naive fashion.

The 'ignore variable names' variant is more general of the naive Unifying AST Match approach as it completes ignores the id/name of the specific variables. Therefore, it can detect reordering variables using the commutative property of mathematical equations (e.g. a * b = b * a).

### Tree Edit Distance
The Tree Edit Distance algorithm compares two AST on a higher level by calculating the smallest number of node-edit operations necessary to transform one tree to another. The higher the tree edit distance, the lower the chance of plagiarism. The specific implementation in Autograder utilizes the RTED algorithm, whose detail could be found in the paper _RTED: A Robust Algorithm for the Tree Edit Distance_.

### Winnowing
The winnowing algorithm does not rely on AST to compare the similarity between two code files. Instead, it does so by comparing the 'fingerprint' generated by sampling the code content. Theoretically, one could analyze two documents by tokenizing each piece of content, group them into chunks of different sizes, and compare how many times a chunk from one document appears in another. However, this approach is highly time-consuming as it needs to scan through chunks of all different sizes. The winnowing algorithm provides an efficiently way of chunk comparison by utilizing fingerprints and is the core behind the Stanford Moss software. More details could be found in the paper _Winnowing: Local Algorithms for Document Fingerprinting_.

### Comment Edit Distance
The algorithms above all prunes away comments as a source for classification. However, sometimes students would simply copy and paste code contents, making comment a valuable evidence as well. The comment edit distance approach utilizes the Levenshtein string edit distance algorithm to calculate the similarity between the comments of two documents.